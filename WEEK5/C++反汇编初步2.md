# C++反汇编初步2

## 寄存器的划分
在32位cpu架构下，以通用寄存器eax为例

- eax : 32位寄存器
- ax : eax的低位16位寄存单元
- al,ah : 分别为ax的低8位和高8位寄存单元
在64位cpu架构下，对应的是64位的rax

## 特殊的寄存器标志位寄存器
标志位寄存器是一个16位的寄存器，用来标志一些状态

- OF溢出标志位 : 若上一次计算结果溢出，则该位置1，否则置0
- SF符号标志位 : 若上一次计算结果符号位为1则该位置1否则置0
- PF奇偶标志位 : 操作数1的位数为偶，则置1，否则置0
- ZF 零标志位 : 若上次计算结果为0则置1，否则置0
- CF 进位借位标志位 : 若运算产生了最高位向更高位的借位或借位，则置1否则置0

## 寻址
### 1.直接寻址
使用[address](address可以是立即数，也可以是寄存器)来取address这个地址单元开始的特定大小的数据，具体大小取决于所使用的指令。
### 2.间接寻址
与直接寻址类似，只是将address替换成一个表达式，一般格式如下[r1*k+r2+c] .其中r1，r2为寄存器，k为小于等于32的2的整数次幂，c为一个立即数

## 数组
数组在内存中是连续分布的，使用简介寻址的方式就可以很方便地实现。反汇编一维数组很容易，根据间接寻址的偏移量就可以推断出大致的源代码。在反汇编多维数组时时需要根据上下文先推断出数组的前几个维度的大小。
